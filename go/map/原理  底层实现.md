
- 结构：`hmap` + buckets（每个 bucket 最多 8 个元素）+ 可能的 overflow 链
    
- 查找：hash → 定位 bucket → 用 **tophash** 快速筛 → 比较 key → 命中
    
- 扩容：两种触发（装载因子高 / 溢出桶多），**按需渐进迁移**
    
- 复杂度：平均 O(1)
    
- 线程安全：**并发写会 panic**，读写同时也不安全
    
- 迭代：起点随机、次序不稳定（避免依赖顺序）
---
## 1) 核心数据结构

- **hmap**：管理整张表的头部，包含
    
    - `count`：元素数量（`len(map)` 就看它）
        
    - `B`：桶数量 = `2^B`
        
    - `buckets`：指向 bucket 数组
        
    - `oldbuckets`：扩容中旧桶的数组
        
    - 随机 **hash 种子**（每张 map 一份，防碰撞攻击）
        
- **bucket（bmap）**：
    
    - 最多放 **8 对** key/value
        
    - 有一个 `tophash[8]`：存放每个 key 的 **hash 高 8 位**（+一些状态码），用于快速过滤
        
    - 放不下时用 **overflow bucket** 串起来
        

> 为什么要有 tophash？—— 查找时先比“高 8 位”，能迅速排除 90% 以上的非目标位，再做真正的 key 比较，快。

---
### 2) 插入 / 查找 / 删除（简化流程）

#### 插入（`m[k]=v`）

1. 计算 `hash(k)`，用低位定位到 bucket：`bucketIdx = hash & (2^B - 1)`
    
2. 在该 bucket 的 8 个槽位里找空位（或去 overflow 链）
    
3. 写入 key/value，并在对应槽位记录 tophash（hash 的高 8 位）
    
4. 如果装载因子或溢出过多，触发扩容（见下）
    
#### 查找（`v, ok := m[k]`）

1. 同样定位 bucket
    
2. 顺序扫该 bucket 的 `tophash[8]`，**先比 tophash**，相等才继续比 key
    
3. 没找到就沿 overflow 链继续
    
#### 删除（`delete(m, k)`）

1. 定位、查找
    
2. 清掉该槽位的 key/value，并把对应 tophash 标为 empty（有特殊标记值）
    
3. 可能留下“空洞”，**不会立刻回收 bucket**
    

---

## 3) 扩容（增长 & 渐进式迁移）

扩容有两种触发：

- **装载因子过高**（平均每个 bucket 的元素数接近/超过阈值，约 6.5 左右）
    
- **overflow 桶太多**（说明冲突严重、局部拥塞）
    

扩容时通常把桶数 **翻倍**（`B++`），做法是：

- 分配新 `buckets`，旧的存到 `oldbuckets`
    
- 不一次性搬迁，而是 **渐进迁移**：
    
    - 之后的每次读/写/删，都会顺手 **“捎带搬”** 一些旧桶里的元素到新桶
        
    - 查找时如果发现该桶未搬完，就去旧桶查
        
    - 直到所有旧桶都“疏散”完，`oldbuckets` 才清掉
        

> 好处：避免一次性大停顿，**摊还**扩容成本。

---

## 4) 迭代特性

- 迭代（`for k,v := range m`）的**起始位置随机**、顺序不稳定
    
- 在扩容迁移期，迭代器能够遍历到所有元素，但**顺序更不可预测**
    
- **不要**依赖 `map` 的遍历顺序（官方故意打乱）
    

---
## 5) 可比较性 / key 规则（常见坑）

- **key 必须可比较**：`int/string/指针/数组/只含可比较字段的 struct` 等
    
- **float 作 key 不推荐**：精度 & `NaN` 问题（`NaN != NaN`）
    
- **指针作 key**：比较的是地址
    
- **struct 作 key**：逐字段比较；若字段含切片/map/函数 → 不可比较 → 编译不过
---
### 6) 并发与安全

- `map` **不是线程安全**的
    
    - **并发写**自 Go 1.6 起会 **panic**
        
    - 并发读写也不安全
        
- 多协程读写请用：
    
    - 互斥锁 `sync.Mutex/RWMutex` 包裹
        
    - 或 `sync.Map`（适合读多写少、key 稀疏的场景）
---
## 7) 容量与预分配

- `make(map[K]V, hint)` 的 `hint` 是“**元素个数的预估**”，运行时会据此估算初始桶数，**减少扩容**
    
- 和切片不同：`map` **没有 cap** 的概念，只有 `len`
    
- 预估合理会减少溢出桶与扩容次数，提升插入性能（尤其批量构建时）
    

---

## 8) 复杂度与性能小结

- 平均插入/查询/删除 ≈ **O(1)**
    
- 冲突高或溢出多时退化（仍较快，因 tophash+局部性）
    
- 合理的 `hint`、均匀的哈希、避免“巨型 key”（大 struct）都能显著提速
    

---

## 9) 小示例：预分配的好处

```go
//批量插入前做预估 
m := make(map[int]struct{}, 100000) // 预分配约 10 万元素 
for i := 0; i < 100000; i++ {     
	m[i] = struct{}{} 
}
```

对比 `make(map[int]struct{})` 再逐步插入，前者通常更少扩容、更快。