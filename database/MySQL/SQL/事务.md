事务（Transaction）是数据库管理系统（DBMS）中**一组作为单一逻辑单元执行的操作集合**，这些操作要么**全部成功**，要么**全部回滚**，以保证数据的一致性和完整性。

它是保证数据库在并发、异常、故障等情况下仍能保持可靠的核心机制。

---
### 事务的四大特性（ACID）

1. **原子性（Atomicity）**
    
    - 事务是不可分割的最小执行单元
        
    - 要么全部执行成功，要么全部不执行（失败时回滚到事务开始前的状态）
        
2. **一致性（Consistency）**
    
    - 事务执行前后，数据库必须保持一致性约束
        
    - 例如：银行转账时，A 减少的钱数必须等于 B 增加的钱数，不能“凭空消失”或“凭空增加”
        
3. **隔离性（Isolation）**
    
    - 多个事务并发执行时，彼此之间互不干扰
        
    - 数据库会通过不同的**隔离级别**（如 Read Committed、Repeatable Read、Serializable）控制并发行为
        
4. **持久性（Durability）**
    
    - 事务一旦提交，其对数据库的修改就是永久的，即使系统崩溃也不会丢失
---
### 举例（银行转账）

假设用户 A 向用户 B 转账 100 元，事务包含两步：

1. 查询 A 的帐户余额
	
2. 从 A 的账户扣除 100 元
    
3. 给 B 的账户增加 100 元
    
如果中途服务器断电，事务机制会**回滚**到操作前的状态，避免出现“钱从 A 扣了，但 B 没收到”的情况。

---
在 SQL 中的事务控制
```sql
-- 开始事务
BEGIN;
-- 或
START TRANSACTION

-- 扣除 A 账户余额
UPDATE accounts SET balance = balance - 100 WHERE user_id = 'A';

-- 增加 B 账户余额
UPDATE accounts SET balance = balance + 100 WHERE user_id = 'B';

-- 提交事务
COMMIT;

-- 如果出错则回滚
ROLLBACK;

```

---
## 并发事务问题

就是多个事务**同时执行**时，因为要访问或修改**同一批数据**，导致出现**数据不一致**的现象。

数据库设计事务的 **隔离性（Isolation）** 就是为了解决这些问题，但如果隔离级别不够，就会出现以下经典并发问题：
## 1. 脏读（Dirty Read）

![[Pasted image 20250813023718.png]]

- **现象**：事务 B 读到了事务 A **还没提交**的数据
    
- **风险**：A 回滚后，B 读到的数据是无效的
    
- **例子**：
    
    1. 事务 A：`UPDATE account SET money=0 WHERE name='张三';`（未提交）
        
    2. 事务 B 读取到 money=0
        
    3. B 执行 `ROLLBACK`  
        → A 的读取结果成了“脏数据”
        

---

## 2. 不可重复读（Non-repeatable Read）

![[Pasted image 20250813023904.png]]

- **现象**：同一事务中，两次读取**同一行**数据的结果不一致
    
- **原因**：中途有别的事务修改并提交了该行数据
    
- **例子**：
    
    1. 事务 A：`SELECT money FROM account WHERE name='张三';` → 结果 2000
        
    2. 事务 B：`UPDATE account SET money=0 WHERE name='张三'; COMMIT;`
        
    3. 事务 A 再次执行同样的查询 → 结果变成 0
        

---
 
## 3. 幻读（Phantom Read）

![[Pasted image 20250813024315.png]]

- **现象**：同一事务中，两次读取**满足条件的多行数据**，第二次结果多了或少了行
    
- **原因**：中途有其他事务插入或删除了符合条件的数据
    
- **例子**：
    
    1. 事务 A：`SELECT * FROM account WHERE money > 1000;` → 返回 3 行
        
    2. 事务 B：`INSERT INTO account VALUES(NULL,'王五',5000); COMMIT;`
        
    3. 事务 A 再查 → 返回 4 行（出现了“幻影”行）
        

---

## 4. 丢失更新（Lost Update）

- **现象**：两个事务同时修改同一行数据，后提交的事务**覆盖**了先提交事务的修改
    
- **例子**：
    
    - A 和 B 同时读取 money=2000
        
    - A：money -= 500 → 更新成 1500（提交）
        
    - B：money -= 200 → 覆盖成 1800（A 的修改丢了）
        

---

## 事务隔离级别与问题对应关系

|隔离级别|能看到其他事务未提交的数据？|能否避免脏读|能否避免不可重复读|能否避免幻读|
|---|---|---|---|---|
|**Read Uncommitted**（读未提交）|✅ 可以|❌|❌|❌|
|**Read Committed**（读已提交）|❌|✅|❌|❌|
|**Repeatable Read**（可重复读，MySQL InnoDB 默认）|❌|✅|✅|❌*|
|**Serializable**（可串行化）|❌|✅|✅|✅|

> * MySQL InnoDB 在 Repeatable Read 下用 **间隙锁（Gap Lock）** 可以避免幻读，但标准 SQL 认为仍可能发生

###  2️⃣ 各隔离级别特点

### **① Read Uncommitted**（读未提交）

- 最低级别，几乎不加锁
    
- 可以读到**未提交事务**的数据（脏读）
    
- 并发性能高，但数据一致性差
    
- **适用场景**：对数据一致性要求极低的统计、日志类查询

---

### **② Read Committed**（读已提交）

- 只能读到其他事务**已提交**的数据
    
- 避免了脏读，但仍可能出现**不可重复读**和**幻读**
    
- **Oracle、SQL Server 默认级别**
    
- **适用场景**：业务更注重实时性，不太介意同一事务内读取到的数据前后不一致
---

### **③ Repeatable Read**（可重复读）

- 同一事务内，多次读取同一行数据**结果一致**
    
- 避免了脏读和不可重复读
    
- 仍可能出现幻读（但 MySQL InnoDB 通过间隙锁大多情况下能避免）
    
- **MySQL InnoDB 默认级别**
    
- **适用场景**：转账、库存等要求读取一致性较高的场景

---

### **④ Serializable**（可串行化）

- 最高级别，强制事务按顺序执行
    
- 相当于加了表级锁，彻底避免所有并发问题
    
- 并发性能最差
    
- **适用场景**：极端要求一致性的业务（如银行核心账务）

---

## 3️⃣ MySQL 查看和设置隔离级别

```sql
-- 查看当前会话隔离级别
SELECT @@transaction_isolation;
[REPEATABLE READ] [READ UNCOMMITTED] [READ COMMITTED] [SERIALIZABLE]
-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 设置全局隔离级别（对新连接生效）
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;


````