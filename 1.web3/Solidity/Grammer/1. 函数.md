函数修饰符

- `modifier` 是一段可复用的前/后置逻辑，可套在函数签名上，对函数执行做**条件检查、状态切换、重入保护**等。
    
- 语法里用占位符 `_;` 表示“函数主体在这里执行”。`_;` 前面的代码在函数体之前跑，后面的在之后跑；也可以出现多次（极少用）。
    
- 修饰符可以 `virtual` / `override`，可继承与重写；也能带**参数**。
    
- 可用于普通函数、`constructor`、`receive`/`fallback`（常见于访问控制/防暂停）。
    
- 注意：`view/pure/payable`、`public/external/internal/private` 是**函数状态/可见性说明符**，不是 `modifier`

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}

function setX(uint x) external onlyOwner {
    value = x;
}
```

calldata  storage memory

|位置|存在于哪|生命周期|是否可改|典型用途|成本&拷贝|
|---|---|---|---|---|---|
|`calldata`|交易输入 / 外部调用参数区|仅当前外部调用期间|**不可改**（只读）|`external` 函数的数组/字符串/struct 参数；避免把大数组拷贝进内存|**最省**：零拷贝读取；把它转为 `memory` 会产生一次复制|
|`memory`|EVM 内存（临时）|调用栈帧期间|可改|计算中间结果、返回数组/字符串、ABI 解码结果|**中等**：申请/扩容有成本；函数返回的动态数据通常是 `memory`|
|`storage`|合约永久状态槽（state）|合约存在期|可改|状态变量、持久化结构（mapping/数组/struct）|**最贵**：`SLOAD/SSTORE` 昂贵；是“引用语义”|